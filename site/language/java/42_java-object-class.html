<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8">
<title>Java Object 类</title>
</head>
<body>
<div class="article-intro" id="content">
			
			<h1>Java Object 类</h1><p>&#13;
Java Object 类是所有类的父类，也就是说 Java 的所有类都继承了 Object，<strong>子类可以使用 Object 的所有方法</strong>。</p>&#13;
<p><img decoding="async" src="https://www.runoob.com/wp-content/uploads/2020/10/classes-object.gif"/></p>&#13;
<p>&#13;
Object 类位于 java.lang 包中，编译时会自动导入，我们创建一个类时，如果没有明确继承一个父类，那么它就会自动继承 Object，成为 Object 的子类。</p><p>&#13;
Object 类可以显式继承，也可以隐式继承，以下两种方式是一样的：</p>&#13;
&#13;
<p>显式继承:</p>&#13;
<pre>public class Runoob extends Object{&#13;
&#13;
}</pre>&#13;
<p>隐式继承:</p>&#13;
<pre>public class Runoob {&#13;
&#13;
}</pre>&#13;
<h3>类的构造函数</h3>&#13;
<table class="reference">&#13;
<tbody><tr>&#13;
<th style="width:5%">序号</th>&#13;
<th style="text-align:center;">构造方法 &amp; 描述</th>&#13;
</tr>&#13;
<tr>&#13;
<td>1</td>&#13;
<td>&#13;
<p><b>Object()</b></p>&#13;
<p>构造一个新对象。</p>&#13;
</td>&#13;
</tr>&#13;
</tbody></table>&#13;
<h3>类的方法</h3>&#13;
<table class="reference">&#13;
<tbody><tr>&#13;
<th style="width:5%">序号</th>&#13;
<th style="text-align:center;">方法 &amp; 描述</th>&#13;
</tr>&#13;
<tr>&#13;
<td>1</td>&#13;
<td><a href="/java/java-object-clone.html">protected Object clone()</a>&#13;
<p>创建并返回一个对象的拷贝</p>&#13;
</td>&#13;
</tr>&#13;
<tr>&#13;
<td>2</td>&#13;
<td><a href="/java/java-object-equals.html">boolean equals(Object obj)</a>&#13;
<p>比较两个对象是否相等</p>&#13;
</td>&#13;
</tr>&#13;
<tr>&#13;
<td>3</td>&#13;
<td><a href="/java/java-object-finalize.html">protected void finalize()</a>&#13;
<p>当 GC (垃圾回收器)确定不存在对该对象的有更多引用时，由对象的垃圾回收器调用此方法。</p>&#13;
</td>&#13;
</tr>&#13;
<tr>&#13;
<td>4</td>&#13;
<td><a href="/java/java-object-getclass.html">Class&lt;?&gt; getClass()</a>&#13;
<p>获取对象的运行时对象的类</p>&#13;
</td>&#13;
</tr>&#13;
<tr>&#13;
<td>5</td>&#13;
<td><a href="/java/java-object-hashcode.html">int hashCode()</a>&#13;
<p>获取对象的 hash 值</p>&#13;
</td>&#13;
</tr>&#13;
<tr>&#13;
<td>6</td>&#13;
<td><a href="/java/java-object-notify.html">void notify()</a>&#13;
<p>唤醒在该对象上等待的某个线程</p>&#13;
</td>&#13;
</tr>&#13;
<tr>&#13;
<td>7</td>&#13;
<td><a href="/java/java-object-notifyall.html">void notifyAll()</a>&#13;
<p>唤醒在该对象上等待的所有线程</p>&#13;
</td>&#13;
</tr>&#13;
<tr>&#13;
<td>8</td>&#13;
<td><a href="/java/java-object-tostring.html">String toString()</a>&#13;
<p>返回对象的字符串表示形式</p>&#13;
</td>&#13;
</tr>&#13;
<tr>&#13;
<td>9</td>&#13;
<td><a href="/java/java-object-wait.html">void wait()</a>&#13;
<p>让当前线程进入等待状态。直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法。</p>&#13;
</td>&#13;
</tr>&#13;
<tr>&#13;
<td>10</td>&#13;
<td><a href="/java/java-object-wait-timeout.html">void wait(long timeout)</a>&#13;
<p>让当前线程处于等待(阻塞)状态，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者超过参数设置的timeout超时时间。</p>&#13;
</td>&#13;
</tr>&#13;
<tr>&#13;
<td>11</td>&#13;
<td><a href="/java/java-object-wait-nanos.html">void wait(long timeout, int nanos)</a>&#13;
<p>与 wait(long timeout) 方法类似，多了一个 nanos 参数，这个参数表示额外时间（以纳秒为单位，范围是 0-999999）。 所以超时的时间还需要加上 nanos 纳秒。。</p>&#13;
</td>&#13;
</tr>&#13;
</tbody></table>			<!-- 其他扩展 -->
						
			</div>
			
		
</body>
</html>